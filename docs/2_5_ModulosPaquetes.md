---
title: Gesti√≥n de m√≥dulos, paquetes y entornos virtuales
description: Introducci√≥n a Python. Gesti√≥n de m√≥dulos, paquetes y entornos virtuales
---

En este apartado nos centraremos en saber qu√© son los m√≥dulos en Python y c√≥mo se utilizan para organizar y reutilizar c√≥digo. Se explicar√° c√≥mo importar m√≥dulos est√°ndar como `math` o `datetime`, as√≠ como c√≥mo crear y utilizar m√≥dulos propios. El objetivo es que se comprenda la importancia de dividir el c√≥digo en partes funcionales y c√≥mo acceder a funciones, clases o variables definidas en otros archivos mediante distintas formas de importaci√≥n.

Adem√°s, se introducir√° el uso de paquetes externos mediante el gestor `pip`, que permite instalar librer√≠as desarrolladas por terceros. Se aprender√° a instalar, listar y desinstalar paquetes, as√≠ como a utilizar herramientas como `pip freeze` para capturar las dependencias de un proyecto. Se busca que el alumno sea capaz de incorporar nuevas funcionalidades a sus programas sin necesidad de desarrollarlas desde cero, aprovechando el ecosistema abierto de Python.

Por √∫ltimo, se abordar√° la creaci√≥n y gesti√≥n de entornos virtuales con `venv`, una herramienta fundamental para trabajar en proyectos profesionales. Se aprender√° a crear un entorno aislado, activarlo, instalar paquetes dentro de √©l y generar un archivo `requirements.txt` para compartir las dependencias. El objetivo es que comprenda c√≥mo evitar conflictos entre proyectos y c√≥mo mantener un entorno limpio y controlado para cada desarrollo.

B√°sicamente, los contenidos que vamos a abordar en esta secci√≥n son:

- Uso de `import`, `from ... import ...`, y alias con `as`.
- Instalaci√≥n de paquetes con `pip install`.
- Listado y desinstalaci√≥n de paquetes (`pip list`, `pip uninstall`).
- Creaci√≥n de entornos virtuales con `venv`.
- Activaci√≥n y uso de entornos virtuales.
- Archivo `requirements.txt` para compartir dependencias.

## Introducci√≥n a los m√≥dulos

Un **m√≥dulo** en Python es simplemente un archivo `.py` que contiene funciones, clases o variables que pueden ser reutilizadas en otros programas. 

Python incluye muchos **m√≥dulos est√°ndar** como `math`, `random` o `datetime`, y tambi√©n permite crear los tuyos **propios**.

Para poder trabajar con un m√≥dulo, en la cabecera del fichero de c√≥digo lo debemos importar mediante el comando `import`;

!!!example "Importaci√≥n de m√≥dulo `math`"

    ```python
    import math
    print(math.sqrt(25))  # 5.0
    ```

Tambi√©n se puede importar solo una parte del m√≥dulo mediante `from <m√≥dulo> import <funcion>`:

!!!example "Importaci√≥n de funci√≥n `pi` de m√≥dulo `math`"

    ```python
    from math import pi
    print(pi)  # 3.141592...
    ```
Observar que en el primer caso para el uso de una funci√≥n concreta necesitamos indicar `modulo.funcion()` mientras que al importar una funci√≥n directamente, no es necesario indicar el m√≥dulo al que pertenece.

Y tambi√©n se puede usar alias para acortar nombres de los m√≥dulos:

!!!example "Ejemplo de uso de alias para identificar un m√≥dulo"

    ```python
    import datetime as dt
    print(dt.datetime.now())
    ```

Por supuestos, python dispone de una serie de m√≥dulos de todo tipo que podemos usar, a parte de los que podamos desarrollar o usar de otros desarrolladores.

!!!tip "Informaci√≥n sobre los m√≥dulos en Python"

    La fuente m√°s fiable y completa. En ella puedes consultar todos los m√≥dulos est√°ndar, sus funciones, clases y ejemplos de uso.

    [https://docs.python.org/es/3/library/index.html](https://docs.python.org/es/3/library/index.html)

    Por ejemplo, si quieres saber qu√© ofrece el m√≥dulo `math`, puedes ir directamente a:

    [https://docs.python.org/es/3/library/math.html](https://docs.python.org/es/3/library/math.html)


## Uso de m√≥dulos propios en Python

Como programadores, podemos crear m√≥dulos (archivos) donde definimos funciones que despu√©s vamos a reutilizar en nuestro/s proyectos. 

Cuando tenemos funciones definidas en un archivo como `utils.py`, podemos reutilizarlas en otros archivos del mismo proyecto import√°ndolas. No es necesario hacer nada especial para ‚Äúexportarlas‚Äù: basta con que est√©n definidas correctamente y que el archivo est√© en la misma carpeta (o en una ruta accesible).

Por ejemplo, veamos el caso de si tenemos un fichero para m√≥dulos y otro principal

!!!example "Uso de m√≥dulos propios"

    Supongamos que tenemos esta estructura:

    ```plaintext
    mi_proyecto/
    ‚îú‚îÄ‚îÄ utils.py
    ‚îî‚îÄ‚îÄ main.py
    ```

    Y en `utils.py` tenemos:

    ```python
    def saludar(nombre):
        return f"Hola, {nombre}!"

    def sumar(a, b):
        return a + b
    ```

    Entonces en `main.py` podemos importar estas funciones as√≠:

    ```python
    from utils import saludar, sumar

    print(saludar("Sergio"))
    print(sumar(3, 5))
    ```

    Tambi√©n podemos importar todo el m√≥dulo completo:

    ```python
    import utils

    print(utils.saludar("Luc√≠a"))
    print(utils.sumar(10, 7))
    ```

Ambas formas son v√°lidas. La primera importa funciones espec√≠ficas, la segunda importa el m√≥dulo completo.

### üß© Ejemplo y ejercicio de uso

Veamos el siguiente ejemplo

!!!example "Ejemplo de uso de m√≥dulos propios"

    **Archivo `utils.py`**

    ```python
    def convertir_mayusculas(texto):
        return texto.upper()

    def obtener_longitud(texto):
        return len(texto)
    ```

    **Archivo `main.py`**

    ```python
    from utils import convertir_mayusculas, obtener_longitud

    frase = "Hola desde Alberic"
    print(convertir_mayusculas(frase))       # HOLA DESDE ALBERIC
    print(obtener_longitud(frase))           # 18
    ```

Este ejemplo muestra c√≥mo separar funciones en un m√≥dulo y usarlas desde otro archivo.

!!!question "Ejercicio: Crear m√≥dulo de utilidades y usarlo desde otro archivo"

    Crea un archivo llamado `utils.py` que contenga las siguientes funciones:

    - `es_par(n)`: devuelve `True` si el n√∫mero es par.
    - `formatear_nombre(nombre)`: devuelve el nombre con la primera letra en may√∫scula y el resto en min√∫scula.

    Luego crea otro archivo llamado `main.py` que:

    1. Importe las funciones desde `utils.py`.
    2. Pida al usuario un n√∫mero y un nombre.
    3. Muestre si el n√∫mero es par.
    4. Muestre el nombre formateado.

    > Pistas  
    > - Usa `input()` para recoger datos.  
    > - Usa `from utils import ...` para importar funciones.  
    > - Usa `int()` para convertir el n√∫mero.
    > - Calcula el resto para saber si es por o no y utiliza la funcion `texto.capitaliza()` para pasar solo la primera letra a mayusculas  

    ???quote "Soluci√≥n"

        **Archivo `utils.py`**

        ```python
        def es_par(n):
            return n % 2 == 0

        def formatear_nombre(nombre):
            return nombre.capitalize()
        ```

        **Archivo `main.py`**

        ```python
        from utils import es_par, formatear_nombre

        numero = int(input("Introduce un n√∫mero: "))
        nombre = input("Introduce tu nombre: ")

        if es_par(numero):
            print("El n√∫mero es par.")
        else:
            print("El n√∫mero es impar.")

        print("Nombre formateado:", formatear_nombre(nombre))
        ```


## Instalaci√≥n de paquetes con `pip`

**`pip`** es el gestor de paquetes oficial de Python. Permite instalar librer√≠as externas que no vienen incluidas por defecto. Por ejemplo, para instalar la librer√≠a `requests`:

```bash
pip install requests
```

Una vez instalada, puedes usarla en tu c√≥digo:

!!!example "Ejemplo de uso de librer√≠a `request`

    ```python
    import requests
    respuesta = requests.get("https://www.google.com")
    print(respuesta.status_code)
    ```

Si intentamos hacer el `import` de un paquete no instalado en el sistema, entonces tendremos un error.

<figure markdown="span" align="center">
  ![Image title](./imgs/python/error-libreria-no-instalada.png){ width="75%"  }
  <figcaption>Error por falta de librer√≠a "emoji"</figcaption>
</figure>

Para ver qu√© paquetes tienes instalados:

```bash
pip list
```

Para desinstalar uno:

```bash
pip uninstall <<nombre_paquete>>
```

---

## Entornos virtuales

Un **entorno virtual** es una carpeta aislada que contiene su propia instalaci√≥n de Python y sus propios paquetes. Esto evita conflictos entre proyectos y permite mantener cada uno con sus dependencias espec√≠ficas.

Esto nos permite crear aplicaciones y tener instalados todos los paquetes de forma aislada, de forma que los paquetes de una aplicaci√≥n no interfieren con los de otra. Esto puede parecer trivial, pero no lo es, puesto que podemos usar diferentes versiones de paquetes en aplicaciones diferentes.

Para crear un entorno virtual:

```bash
python -m venv mi_entorno
```

Esto crea una carpeta llamada `mi_entorno`. Para activarlo:

- En Windows:
  ```bash
  mi_entorno\Scripts\activate
  ```
- En macOS/Linux:
  ```bash
  source mi_entorno/bin/activate
  ```

Una vez activado, puedes instalar paquetes con `pip` y quedar√°n guardados solo en ese entorno.

Para salir del entorno:

```bash
deactivate
```

Veamos un ejemplo que clarificar√° c√≥mo se aplica:

<figure markdown="span" align="center">
  ![Image title](./imgs/python/entorno-virtual.png){ width="75%"  }
  <figcaption>Entorno Virtual en Python</figcaption>
</figure>

En el ejemplo anterior podemos ver los siguientes pasos:

1. Se crea un entorno virtual `vsge` y se activa
2. Se instala el paquete `emogi`
3. Se comprueba que el paquete esta instalado
4. Se sale del entorno virtual
5. Se comprueba que el paquete `emogi` no esta instalado, por lo que se demuestra que solo queda instalado si se utiliza con el entorno activo.


### Trabajando con entornos virtuales y organizaci√≥n de m√≥dulos

La forma m√°s aconsejable y profesional de organizar un proyecto con entorno virtual es **trabajar en una carpeta base del proyecto** y tener el entorno virtual como una **subcarpeta dentro de ella**. Esto permite mantener el c√≥digo fuente, los archivos de configuraci√≥n, los datos y el entorno virtual **bien separados y estructurados**, lo que facilita el mantenimiento, la colaboraci√≥n y el despliegue.

Adem√°s, cuando el proyecto crece, es habitual agrupar funciones propias en **subcarpetas** que act√∫an como paquetes. Esto mejora la modularidad y permite importar funciones desde distintos archivos sin mezclar todo en un √∫nico m√≥dulo. Para que una subcarpeta sea tratada como paquete, debe contener un archivo `__init__.py`, aunque est√© vac√≠o.

!!!note "El fichero `__init__.py`"

    El archivo `__init__.py` indica que una carpeta debe ser tratada como un paquete de Python. Aunque en versiones modernas ya no es obligatorio, sigue siendo una buena pr√°ctica incluirlo.
    
    Aunque el archivo `__init__.py` puede estar vac√≠o, tambi√©n puede incluir **c√≥digo √∫til de inicializaci√≥n** para el paquete. Esto permite controlar qu√© funciones, clases o subm√≥dulos se exponen al importar el paquete, definir constantes globales, o incluso agrupar accesos para simplificar el uso desde fuera.

    Por ejemplo, si tienes varios m√≥dulos en la carpeta `utilidades/`, puedes usar `__init__.py` para importar funciones clave y facilitar el acceso desde el exterior:

    ```python
    # utilidades/__init__.py
    from .texto import formatear_mensaje
    from .numeros import es_par
    ```

    Esto permite que desde `main.py` puedas hacer:

    ```python
    from utilidades import formatear_mensaje, es_par
    ```

    En lugar de tener que importar cada m√≥dulo por separado. Tambi√©n puedes definir constantes o funciones que se ejecuten al cargar el paquete:

    ```python
    # utilidades/__init__.py
    VERSION = "1.0"

    def iniciar():
        print("Paquete utilidades cargado correctamente.")
    ```

    Este enfoque es √∫til cuando quieres que el paquete tenga un comportamiento inicial o una configuraci√≥n com√∫n.

De hecho, podemos decir que tenemos una estructura base t√≠pica a la hora de crear un proyecto en Python que ser√≠a similar a la mostrada en el siguiente ejemplo:

!!!example "Estructura recomendada"

    ```plaintext
    mi_proyecto/
    ‚îú‚îÄ‚îÄ venv/                     ‚Üê entorno virtual (subcarpeta)
    ‚îú‚îÄ‚îÄ main.py                   ‚Üê c√≥digo principal
    ‚îú‚îÄ‚îÄ utilidades/              ‚Üê paquete con m√≥dulos propios
    ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py          ‚Üê indica que es un paquete
    ‚îÇ   ‚îî‚îÄ‚îÄ texto.py             ‚Üê m√≥dulo con funciones de texto
    ‚îú‚îÄ‚îÄ requirements.txt         ‚Üê dependencias del proyecto
    ‚îú‚îÄ‚îÄ README.md                ‚Üê documentaci√≥n
    ‚îî‚îÄ‚îÄ datos/                   ‚Üê archivos de entrada/salida
    ```

Esta estructura permite que el entorno virtual est√© contenido dentro del proyecto, pero **no mezclado con el c√≥digo**. Tambi√©n facilita que puedas subir tu proyecto a GitHub o compartirlo sin incluir el entorno virtual (que suele a√±adirse al `.gitignore`). Al mismo tiempo, el uso de paquetes como `utilidades/` permite mantener el c√≥digo organizado y reutilizable.

!!!tip "Ejemplo de invocaci√≥n de funciones desde un m√≥dulo en subcarpeta"

    Si tienes una funci√≥n `formatear_mensaje()` definida en `utilidades/texto.py`, puedes usarla desde `main.py` as√≠:

    ```python
    from utilidades.texto import formatear_mensaje

    print(formatear_mensaje("hola desde Valencia"))
    ```

    Recuerda que la carpeta `utilidades` debe contener un archivo `__init__.py` para que Python la reconozca como paquete.

En el siguiente apartado hablaremos el archivo `requirements.txt`

### Usos t√≠picos de los entornos virtuales

Un entorno virtual no es solo para instalar paquetes. Tambi√©n te permite:

- **Usar una versi√≥n espec√≠fica de Python** (si lo creas con `pyenv` o herramientas similares).
- **Ejecutar scripts con dependencias aisladas**, sin interferencias de otros proyectos.
- **Probar diferentes versiones de librer√≠as** sin afectar tu sistema.
- **Instalar herramientas de desarrollo** como linters, formateadores o frameworks sin contaminar el entorno global.

O sea, el entorno virtual es como una ‚Äúburbuja‚Äù donde puedes trabajar con total libertad, sabiendo que todo lo que instales o configures queda dentro de esa carpeta.



## Archivo `requirements.txt`

Este archivo contiene la lista de paquetes necesarios para un proyecto. Se puede generar autom√°ticamente:

```bash
pip freeze > requirements.txt
```

Y se puede usar para instalar todos los paquetes en otro entorno:

```bash
pip install -r requirements.txt
```

Esto es muy √∫til para compartir proyectos con otros desarrolladores o para desplegar en servidores. En vez de estar instalando manualmente todos los paquetes, mediante este fichero el servidor sabe qu√© paquetes debe instalar (autom√°ticamente).


!!!note "Instalaci√≥n autom√°tica en despliegues"

    En ejecuci√≥n local, Python **no instala autom√°ticamente** los paquetes aunque est√©n en `requirements.txt`. Pero en entornos de despliegue s√≠ se automatiza:

    - **Docker**
    ```dockerfile
    COPY requirements.txt .
    RUN pip install -r requirements.txt
    ```

    - Plataformas como **Heroku** o **GitHub Actions**
    Detectan el fichero y ejecutan autom√°ticamente:
    ```bash
    pip install -r requirements.txt
    ```

    - **Script de arranque personalizado**
    ```bash
    pip install -r requirements.txt && python main.py
    ```


## üß© Ejemplo y ejercicio de uso

El siguiente ejemplo permite crear un flujo que prepara un proyecto web con *Flask* sin afectar otros proyectos.

!!!example "Ejemplo de uso"

    Los siguiente pasos crean en entorno virtual, lo activa, instala el paquete flask y genera el fichero requirements.txt

    ```bash
    # Crear entorno virtual
    python -m venv entorno_web

    # Activar entorno (Windows)
    entorno_web/Scripts/activate

    # Instalar Flask
    pip install flask

    # Guardar dependencias
    pip freeze > requirements.txt

    # Desactivar entorno
    deactivate
    ```

!!!question "Ejercicio: Preparar entorno para proyecto de an√°lisis de datos"

    Imagina que vas a empezar un proyecto de an√°lisis de datos en Python.  
    Crea un entorno virtual llamado `analisis`, instala los paquetes `pandas` y `matplotlib`, y guarda las dependencias en un archivo `requirements.txt`.

    > Pistas  
    > - Usa `python -m venv` para crear el entorno.  
    > - Activa el entorno antes de instalar los paquetes.  
    > - Usa `pip freeze` para generar el archivo.

    ???quote "Soluci√≥n"

        ```bash
        # Crear entorno virtual
        python -m venv analisis

        # Activar entorno (Windows)
        analisis/Scripts/activate

        # Instalar paquetes
        pip install pandas matplotlib

        # Guardar dependencias
        pip freeze > requirements.txt

        # Desactivar entorno
        deactivate
        ```
